// src/index.ts
import {
  convertQuery,
  getMappedQueriesStream
} from "@directus/data-sql";
import { Readable } from "stream";
import pg from "pg";
import QueryStream from "pg-query-stream";

// src/utils/escape-identifier.ts
function escapeIdentifier(identifier) {
  return `"${identifier.replaceAll('"', '""')}"`;
}

// src/utils/wrap-column.ts
function wrapColumn(table, column, as) {
  let base = `${escapeIdentifier(table)}.${escapeIdentifier(column)}`;
  if (as) {
    base += ` AS ${escapeIdentifier(as)}`;
  }
  return base;
}

// src/utils/functions.ts
function applyFunction(fnNode) {
  const wrappedColumn = wrapColumn(fnNode.table, fnNode.column);
  if (fnNode.fn.type === "arrayFn") {
    return `COUNT(${wrappedColumn})`;
  }
  return applyDateTimeFn(fnNode, wrappedColumn);
}
var applyDateTimeFn = (fnNode, col) => {
  switch (fnNode.fn.fn) {
    case "year":
      return applyFn("YEAR", fnNode.fn);
    case "month":
      return applyFn("MONTH", fnNode.fn);
    case "week":
      return applyFn("WEEK", fnNode.fn);
    case "day":
      return applyFn("DAY", fnNode.fn);
    case "weekday":
      return applyFn("DOW", fnNode.fn);
    case "hour":
      return applyFn("HOUR", fnNode.fn);
    case "minute":
      return applyFn("MINUTE", fnNode.fn);
    case "second":
      return applyFn("SECOND", fnNode.fn);
    default:
      throw new Error(`Function ${fnNode} is not supported.`);
  }
  function applyFn(functionName, fn) {
    return `EXTRACT(${functionName} FROM ${col}${fn.isTimestampType ? " AT TIME ZONE 'UTC'" : ""})`;
  }
};

// src/query/select.ts
var select = ({ select: select2 }) => {
  const escapedColumns = select2.map((selectNode) => {
    if (selectNode.type === "primitive") {
      return wrapColumn(selectNode.table, selectNode.column, selectNode.as);
    }
    if (selectNode.type === "fn") {
      return applyFunction(selectNode);
    }
    throw Error(`Unknown node type`);
  });
  return `SELECT ${escapedColumns.join(", ")}`;
};

// src/query/from.ts
function from({ from: from2 }) {
  return `FROM ${escapeIdentifier(from2)}`;
}

// src/query/limit.ts
function limit({ limit: limit2 }) {
  if (limit2 === void 0) {
    return null;
  }
  return `LIMIT $${limit2.parameterIndex + 1}`;
}

// src/query/offset.ts
function offset({ offset: offset2 }) {
  if (offset2 === void 0) {
    return null;
  }
  return `OFFSET $${offset2.parameterIndex + 1}`;
}

// src/utils/conditions/number-condition.ts
import { convertNumericOperators } from "@directus/data-sql";
var numberCondition = (conditionNode, negate) => {
  const target = conditionNode.target;
  let firstOperand;
  if (target.type === "fn") {
    firstOperand = applyFunction(target);
  } else {
    firstOperand = wrapColumn(target.table, target.column);
  }
  const compareValue = `$${conditionNode.compareTo.parameterIndex + 1}`;
  const operation = convertNumericOperators(conditionNode.operation, negate);
  return `${firstOperand} ${operation} ${compareValue}`;
};

// src/utils/conditions/string-condition.ts
var stringCondition = (condition, negate) => {
  const column = wrapColumn(condition.target.table, condition.target.column);
  const compareValue = `$${condition.compareTo.parameterIndex + 1}`;
  if (condition.operation === "eq") {
    return `${column} ${negate ? "!=" : "="} ${compareValue}`;
  }
  let likeValue = "";
  switch (condition.operation) {
    case "contains":
      likeValue = `'%'||${compareValue}||'%'`;
      break;
    case "starts_with":
      likeValue = `${compareValue}||'%'`;
      break;
    case "ends_with":
      likeValue = `'%'||${compareValue}`;
      break;
  }
  return `${column} ${negate ? "NOT LIKE" : "LIKE"} ${likeValue}`;
};

// src/utils/conditions/geo-condition.ts
var geoCondition = (condition) => {
  const column = wrapColumn(condition.target.table, condition.target.column);
  const parameterIndex = condition.compareTo.parameterIndex;
  const geomConvertedText = `ST_GeomFromText($${parameterIndex + 1})`;
  switch (condition.operation) {
    case "intersects":
      return `ST_Intersects(${column}, ${geomConvertedText})`;
    case "intersects_bbox":
      return `${column} && ${geomConvertedText})`;
  }
};

// src/utils/conditions/set-condition.ts
var setCondition = (condition, negate) => {
  const column = wrapColumn(condition.target.table, condition.target.column);
  const compareValues = condition.compareTo.parameterIndexes.map((i) => `$${i + 1}`).join(", ");
  if (negate) {
    return `${column} NOT IN (${compareValues})`;
  }
  return `${column} IN (${compareValues})`;
};

// src/utils/conditions/field-condition.ts
import { convertNumericOperators as convertNumericOperators2 } from "@directus/data-sql";
var fieldCondition = (condition, negate) => {
  const column1 = wrapColumn(condition.target.table, condition.target.column);
  const column2 = wrapColumn(condition.compareTo.table, condition.compareTo.column);
  const operation = convertNumericOperators2(condition.operation, negate);
  return `${column1} ${operation} ${column2}`;
};

// src/utils/conditions/index.ts
var conditionString = (node) => {
  if (node.type === "logical") {
    return applyLogicalCondition(node);
  }
  return getCondition(node);
};
function getCondition(conditionNode) {
  switch (conditionNode.condition.type) {
    case "condition-number":
      return numberCondition(conditionNode.condition, conditionNode.negate);
    case "condition-string":
      return stringCondition(conditionNode.condition, conditionNode.negate);
    case "condition-geo":
      return geoCondition(conditionNode.condition);
    case "condition-set":
      return setCondition(conditionNode.condition, conditionNode.negate);
    case "condition-field":
      return fieldCondition(conditionNode.condition, conditionNode.negate);
  }
}
function applyLogicalCondition(logicalNode) {
  const logicalGroup = logicalNode.childNodes.map((childNode) => {
    if (childNode.type === "condition" || childNode.negate) {
      return conditionString(childNode);
    }
    return `(${conditionString(childNode)})`;
  }).join(logicalNode.operator === "and" ? " AND " : " OR ");
  return logicalNode.negate ? `NOT (${logicalGroup})` : logicalGroup;
}

// src/query/where.ts
var where = ({ where: where2 }) => {
  if (where2 === void 0) {
    return null;
  }
  return `WHERE ${conditionString(where2)}`;
};

// src/query/orderBy.ts
function orderBy({ order }) {
  if (order === void 0) {
    return null;
  }
  const sortExpressions = order.map((o) => {
    if (o.orderBy.type === "primitive") {
      return `${escapeIdentifier(o.orderBy.table)}.${escapeIdentifier(o.orderBy.column)} ${o.direction}`;
    } else {
      return `${applyFunction(o.orderBy)} ${o.direction}`;
    }
  });
  return `ORDER BY ${sortExpressions.join(", ")}`;
}

// src/query/join.ts
var join = ({ joins }) => {
  if (joins === void 0 || joins.length === 0)
    return null;
  let joinString = "";
  for (const join2 of joins) {
    const tableName = escapeIdentifier(join2.table);
    const alias = escapeIdentifier(join2.as);
    const joinCondition = conditionString(join2.on);
    joinString += `LEFT JOIN ${tableName} ${alias} ON ${joinCondition}`;
  }
  return joinString;
};

// src/query/index.ts
function convertToActualStatement(clauses) {
  const statementParts = [select, from, join, where, orderBy, limit, offset];
  const statement = `${statementParts.map((part) => part(clauses)).filter((p) => p !== null).join(" ")};`;
  return statement;
}

// src/query/parameters.ts
import { stringify } from "wellknown";
function convertParameters(params) {
  return convertGeoJsonParameterToWKT(params);
}
function convertGeoJsonParameterToWKT(params) {
  return params.map((p) => {
    if (isGeoJson(p)) {
      return stringify(p);
    }
    return p;
  });
}
function isGeoJson(parameter) {
  if (typeof parameter === "object") {
    const props = Object.keys(parameter);
    if (props.includes("type")) {
      [
        "Point",
        "MultiPoint",
        "LineString",
        "MultiLineString",
        "Polygon",
        "MultiPolygon",
        "GeometryCollection"
      ].includes(parameter.type);
      return true;
    }
  }
  return false;
}

// src/index.ts
var DataDriverPostgres = class {
  #config;
  #pool;
  constructor(config) {
    this.#config = config;
    this.#pool = new pg.Pool({
      connectionString: this.#config.connectionString
    });
  }
  async destroy() {
    await this.#pool.end();
  }
  /**
   * Opens a stream for the given SQL statement.
   *
   * @param pool the PostgreSQL client pool
   * @param sql A parameterized SQL statement
   * @returns A readable web stream for the query results
   * @throw An error when the query cannot be performed
   */
  async getDataFromSource(pool, sql) {
    try {
      const poolClient = await pool.connect();
      const queryStream = new QueryStream(sql.statement, sql.parameters);
      const stream = poolClient.query(queryStream);
      stream.on("end", () => poolClient.release());
      stream.on("error", () => poolClient.release());
      return Readable.toWeb(stream);
    } catch (error) {
      throw new Error("Failed to query the database: ", error);
    }
  }
  /**
   * Converts the abstract query into PostgreSQL and executes it.
   *
   * @param abstractSql The abstract query
   * @returns The database results converted to a nested object
   * @throws An error when the conversion or the database request fails
   */
  async queryDatabase(abstractSql) {
    const statement = convertToActualStatement(abstractSql.clauses);
    const parameters = convertParameters(abstractSql.parameters);
    const stream = await this.getDataFromSource(this.#pool, { statement, parameters });
    return stream;
  }
  async query(query) {
    const converterResult = convertQuery(query);
    const rootStream = await this.queryDatabase(converterResult.rootQuery);
    return getMappedQueriesStream(
      rootStream,
      converterResult.subQueries,
      converterResult.aliasMapping,
      (query2) => this.queryDatabase(query2)
    );
  }
};
export {
  DataDriverPostgres as default
};
