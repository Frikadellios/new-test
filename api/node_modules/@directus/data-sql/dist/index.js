// src/utils/create-unique-alias.ts
import { randomBytes } from "crypto";
var createUniqueAlias = (identifier) => {
  const random = randomBytes(3).toString("hex");
  return `${identifier}_${random}`;
};

// src/query-converter/functions.ts
function convertFn(collection, abstractFunction, idxGenerator, generatedAlias) {
  const fn = {
    type: "fn",
    fn: abstractFunction.fn,
    table: collection,
    column: abstractFunction.field
  };
  if (generatedAlias) {
    fn.as = generatedAlias;
  }
  if (abstractFunction.args && abstractFunction.args?.length > 0) {
    fn.arguments = {
      type: "values",
      parameterIndexes: abstractFunction.args.map(() => idxGenerator.next().value)
    };
  }
  return {
    fn,
    parameters: abstractFunction.args ?? []
  };
}

// src/query-converter/fields/create-join.ts
var createJoin = (currentCollection, relationalField, externalCollectionAlias) => {
  let on;
  if (relationalField.local.fields.length > 1) {
    on = {
      type: "logical",
      operator: "and",
      negate: false,
      childNodes: relationalField.local.fields.map((currentField, index) => {
        const externalField = relationalField.foreign.fields[index];
        if (!externalField) {
          throw new Error(`Missing related foreign key join column for current context column "${currentField}"`);
        }
        return getJoinCondition(currentCollection, currentField, externalCollectionAlias, externalField);
      })
    };
  } else {
    on = getJoinCondition(
      currentCollection,
      relationalField.local.fields[0],
      externalCollectionAlias,
      relationalField.foreign.fields[0]
    );
  }
  const result = {
    type: "join",
    table: relationalField.foreign.collection,
    as: externalCollectionAlias,
    on
  };
  return result;
};
function getJoinCondition(table1, column1, table2, column2) {
  return {
    type: "condition",
    negate: false,
    condition: {
      type: "condition-field",
      target: {
        type: "primitive",
        table: table1,
        column: column1
      },
      operation: "eq",
      compareTo: {
        type: "primitive",
        table: table2,
        column: column2
      }
    }
  };
}

// src/query-converter/modifiers/target.ts
function convertTarget(target, collection, idxGenerator) {
  if (target.type === "primitive") {
    return {
      value: {
        type: "primitive",
        table: collection,
        column: target.field
      },
      joins: []
    };
  } else if (target.type === "fn") {
    const convertedFn = convertFn(collection, target, idxGenerator);
    return {
      value: convertedFn.fn,
      joins: []
    };
  } else {
    const { value, joins } = convertNestedOneTarget(collection, target, idxGenerator);
    return {
      value,
      joins
    };
  }
}
function convertNestedOneTarget(currentCollection, nestedTarget, idxGenerator) {
  const externalCollectionAlias = createUniqueAlias(nestedTarget.nesting.foreign.collection);
  const join = createJoin(currentCollection, nestedTarget.nesting, externalCollectionAlias);
  const { value, joins } = convertTarget(nestedTarget.field, externalCollectionAlias, idxGenerator);
  return {
    value,
    joins: [join, ...joins]
  };
}

// src/query-converter/modifiers/filter/conditions/field.ts
function convertFieldCondition(node, collection, generator, negate) {
  const { value: value1, joins: joins1 } = convertTarget(node.target, collection, generator);
  const { value: value2, joins: joins2 } = convertTarget(node.compareTo, collection, generator);
  return {
    clauses: {
      where: {
        type: "condition",
        negate,
        condition: {
          type: "condition-field",
          operation: node.operation,
          target: value1,
          compareTo: value2
        }
      },
      joins: [...joins1, ...joins2]
    },
    parameters: []
  };
}

// src/query-converter/modifiers/filter/conditions/geo.ts
function convertGeoCondition(node, collection, generator, negate) {
  const { value, joins } = convertTarget(node.target, collection, generator);
  return {
    clauses: {
      where: {
        type: "condition",
        negate,
        condition: {
          type: "condition-geo",
          operation: node.operation,
          target: value,
          compareTo: {
            type: "value",
            parameterIndex: generator.next().value
          }
        }
      },
      joins
    },
    parameters: [node.compareTo]
  };
}

// src/query-converter/modifiers/filter/conditions/string.ts
function convertStringNode(node, collection, generator, negate) {
  const { value, joins } = convertTarget(node.target, collection, generator);
  return {
    clauses: {
      where: {
        type: "condition",
        negate,
        condition: {
          type: node.type,
          operation: node.operation,
          target: value,
          compareTo: {
            type: "value",
            parameterIndex: generator.next().value
          }
        }
      },
      joins
    },
    parameters: [node.compareTo]
  };
}

// src/query-converter/modifiers/filter/conditions/number.ts
function convertNumberNode(node, collection, generator, negate) {
  const { value, joins } = convertTarget(node.target, collection, generator);
  return {
    clauses: {
      where: {
        type: "condition",
        negate,
        condition: {
          type: node.type,
          operation: node.operation,
          target: value,
          compareTo: {
            type: "value",
            parameterIndex: generator.next().value
          }
        }
      },
      joins
    },
    parameters: [node.compareTo]
  };
}

// src/query-converter/modifiers/filter/conditions/set.ts
function convertSetCondition(node, collection, generator, negate) {
  const { value, joins } = convertTarget(node.target, collection, generator);
  return {
    clauses: {
      where: {
        type: "condition",
        negate,
        condition: {
          type: "condition-set",
          operation: node.operation,
          target: value,
          compareTo: {
            type: "values",
            parameterIndexes: Array.from(node.compareTo).map(() => generator.next().value)
          }
        }
      },
      joins
    },
    parameters: [...node.compareTo]
  };
}

// src/query-converter/modifiers/filter/conditions/conditions.ts
function convertCondition(condition, collection, generator, negate) {
  switch (condition.condition.type) {
    case "condition-string":
      return convertStringNode(condition.condition, collection, generator, negate);
    case "condition-number":
      return convertNumberNode(condition.condition, collection, generator, negate);
    case "condition-geo-intersects":
    case "condition-geo-intersects-bbox":
      return convertGeoCondition(condition.condition, collection, generator, negate);
    case "condition-set":
      return convertSetCondition(condition.condition, collection, generator, negate);
    case "condition-field":
      return convertFieldCondition(condition.condition, collection, generator, negate);
  }
}

// src/query-converter/modifiers/filter/logical.ts
function convertLogical(children, operator, negate) {
  const childWhereClauses = children.map(
    (child) => child.clauses.where
  );
  const parameters = children.flatMap((child) => child.parameters);
  const joins = children.flatMap((child) => child.clauses.joins);
  return {
    clauses: {
      where: {
        type: "logical",
        negate,
        operator,
        childNodes: childWhereClauses
      },
      joins
    },
    parameters
  };
}

// src/query-converter/modifiers/filter/filter.ts
var convertFilter = (filter, collection, generator, negate = false) => {
  if (filter.type === "condition") {
    return convertCondition(filter, collection, generator, negate);
  } else if (filter.type === "negate") {
    return convertFilter(filter.childNode, collection, generator, !negate);
  } else if (filter.type === "logical") {
    const children = filter.childNodes.map(
      (childNode) => convertFilter(childNode, collection, generator, false)
    );
    return convertLogical(children, filter.operator, negate);
  } else {
    throw new Error(`Unknown filter type`);
  }
};

// src/query-converter/modifiers/sort.ts
var convertSort = (abstractSorts, collection, idxGenerator) => {
  const result = {
    clauses: {
      joins: [],
      order: []
    }
  };
  abstractSorts.forEach((abstractSort) => {
    const targetConversionResult = convertTarget(abstractSort.target, collection, idxGenerator);
    const orderBy = {
      type: "order",
      orderBy: targetConversionResult.value,
      direction: abstractSort.direction === "descending" ? "DESC" : "ASC"
    };
    result.clauses.order.push(orderBy);
    result.clauses.joins.push(...targetConversionResult.joins);
    return result;
  });
  return result;
};

// src/query-converter/modifiers/modifiers.ts
var convertModifiers = (modifiers, collection, idxGenerator) => {
  const result = {
    clauses: {},
    parameters: []
  };
  if (modifiers.filter) {
    const convertedFilter = convertFilter(modifiers.filter, collection, idxGenerator);
    result.clauses.where = convertedFilter.clauses.where;
    if (convertedFilter.clauses.joins.length > 0) {
      result.clauses.joins = convertedFilter.clauses.joins;
    }
    result.parameters.push(...convertedFilter.parameters);
  }
  if (modifiers.limit) {
    result.clauses.limit = { type: "value", parameterIndex: idxGenerator.next().value };
    result.parameters.push(modifiers.limit.value);
  }
  if (modifiers.offset) {
    result.clauses.offset = { type: "value", parameterIndex: idxGenerator.next().value };
    result.parameters.push(modifiers.offset.value);
  }
  if (modifiers.sort) {
    const sortConversionResult = convertSort(modifiers.sort, collection, idxGenerator);
    result.clauses.order = sortConversionResult.clauses.order;
    if (sortConversionResult.clauses.joins.length > 0) {
      if (result.clauses.joins) {
        result.clauses.joins.push(...sortConversionResult.clauses.joins);
      } else {
        result.clauses.joins = sortConversionResult.clauses.joins;
      }
    }
  }
  return result;
};

// src/query-converter/param-index-generator.ts
function* parameterIndexGenerator() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

// src/query-converter/fields/create-primitive-select.ts
var createPrimitiveSelect = (collection, field, generatedAlias) => {
  const primitive = {
    type: "primitive",
    table: collection,
    column: field,
    as: generatedAlias
  };
  return primitive;
};

// src/query-converter/fields/create-nested-manys.ts
function getNestedMany(collection, field) {
  if (field.nesting.type !== "relational-many")
    throw new Error("Nested o2a not yet implemented!");
  const index = parameterIndexGenerator();
  const nestedFieldNodes = convertFieldNodes(field.nesting.foreign.collection, field.fields, index);
  const nestedModifiers = convertModifiers(field.modifiers, field.nesting.foreign.collection, index);
  const joins = [...nestedFieldNodes.clauses.joins, ...nestedModifiers.clauses.joins ?? []];
  const parameters = [...nestedFieldNodes.parameters, ...nestedModifiers.parameters];
  const clauses = {
    select: nestedFieldNodes.clauses.select,
    from: field.nesting.foreign.collection,
    ...nestedModifiers.clauses,
    joins,
    where: nestedModifiers.clauses.where ? {
      type: "logical",
      operator: "and",
      negate: false,
      childNodes: [nestedModifiers.clauses.where, getRelationConditions(field.nesting, index)]
    } : getRelationConditions(field.nesting, index)
  };
  const generatedAliases = field.nesting.local.fields.map((field2) => [field2, createUniqueAlias(field2)]);
  const generatedAliasMap = Object.fromEntries(generatedAliases);
  const select = generatedAliases.map(([field2, alias]) => createPrimitiveSelect(collection, field2, alias));
  return {
    subQuery: (rootRow) => ({
      rootQuery: {
        clauses,
        parameters: [
          ...parameters,
          ...field.nesting.local.fields.map((field2) => rootRow[generatedAliasMap[field2]])
        ]
      },
      subQueries: nestedFieldNodes.subQueries,
      aliasMapping: nestedFieldNodes.aliasMapping
    }),
    select
  };
}
function getRelationConditions(fieldNesting, idxGenerator) {
  const table = fieldNesting.foreign.collection;
  if (fieldNesting.foreign.fields.length > 1) {
    return {
      type: "logical",
      operator: "and",
      negate: false,
      childNodes: fieldNesting.foreign.fields.map(
        (field) => getRelationCondition(table, field, idxGenerator)
      )
    };
  } else {
    return getRelationCondition(table, fieldNesting.foreign.fields[0], idxGenerator);
  }
}
function getRelationCondition(table, column, idxGenerator) {
  return {
    type: "condition",
    condition: {
      type: "condition-string",
      // could also be a condition-number, but it doesn't matter because both support 'eq'
      operation: "eq",
      target: {
        type: "primitive",
        table,
        column
      },
      compareTo: {
        type: "value",
        parameterIndex: idxGenerator.next().value
      }
    },
    negate: false
  };
}

// src/query-converter/fields/fields.ts
var convertFieldNodes = (collection, abstractFields, idxGenerator) => {
  const select = [];
  const joins = [];
  const parameters = [];
  const aliasMapping = [];
  const subQueries = [];
  for (const abstractField of abstractFields) {
    if (abstractField.type === "primitive") {
      const generatedAlias = createUniqueAlias(abstractField.field);
      aliasMapping.push({ type: "root", alias: abstractField.alias, column: generatedAlias });
      const selectNode = createPrimitiveSelect(collection, abstractField.field, generatedAlias);
      select.push(selectNode);
      continue;
    }
    if (abstractField.type === "nested-single-one") {
      if (abstractField.nesting.type === "relational-many") {
        const externalCollectionAlias = createUniqueAlias(abstractField.nesting.foreign.collection);
        const sqlJoinNode = createJoin(collection, abstractField.nesting, externalCollectionAlias);
        const nestedOutput = convertFieldNodes(externalCollectionAlias, abstractField.fields, idxGenerator);
        aliasMapping.push({ type: "nested", alias: abstractField.alias, children: nestedOutput.aliasMapping });
        joins.push(sqlJoinNode);
        select.push(...nestedOutput.clauses.select);
      }
      continue;
    }
    if (abstractField.type === "nested-union-one") {
      continue;
    }
    if (abstractField.type === "nested-single-many") {
      const nestedManyResult = getNestedMany(collection, abstractField);
      aliasMapping.push({ type: "sub", alias: abstractField.alias, index: subQueries.length });
      subQueries.push(nestedManyResult.subQuery);
      select.push(...nestedManyResult.select);
      continue;
    }
    if (abstractField.type === "fn") {
      const fnField = abstractField;
      const generatedAlias = createUniqueAlias(`${fnField.fn.fn}_${fnField.field}`);
      aliasMapping.push({ type: "root", alias: abstractField.alias, column: generatedAlias });
      const fn = convertFn(collection, fnField, idxGenerator, generatedAlias);
      select.push(fn.fn);
      parameters.push(...fn.parameters);
      continue;
    }
  }
  return {
    clauses: { select, joins },
    subQueries,
    parameters,
    aliasMapping
  };
};

// src/query-converter/converter.ts
var convertQuery = (abstractQuery) => {
  const idGen = parameterIndexGenerator();
  const parameters = [];
  const subQueries = [];
  let clauses;
  let aliasMapping;
  try {
    const convertedFieldNodes = convertFieldNodes(abstractQuery.collection, abstractQuery.fields, idGen);
    clauses = { ...convertedFieldNodes.clauses, from: abstractQuery.collection };
    parameters.push(...convertedFieldNodes.parameters);
    aliasMapping = convertedFieldNodes.aliasMapping;
    subQueries.push(...convertedFieldNodes.subQueries);
  } catch (error) {
    throw new Error(`Failed to convert query fields: ${error.message}`);
  }
  try {
    const convertedModifiers = convertModifiers(abstractQuery.modifiers, abstractQuery.collection, idGen);
    const joins = [...clauses.joins ?? [], ...convertedModifiers.clauses.joins ?? []];
    clauses = { ...clauses, ...convertedModifiers.clauses, joins };
    parameters.push(...convertedModifiers.parameters);
  } catch (error) {
    throw new Error(`Failed to convert query modifiers: ${error.message}`);
  }
  return {
    rootQuery: {
      clauses,
      parameters
    },
    subQueries,
    aliasMapping
  };
};

// src/utils/get-mapped-queries-stream.ts
import { ReadableStream } from "stream/web";

// src/utils/map-result.ts
function mapResult(aliasMapping, rootRow, subResult) {
  const result = {};
  for (const aliasObject of aliasMapping) {
    if (aliasObject.type === "root") {
      result[aliasObject.alias] = rootRow[aliasObject.column];
    } else if (aliasObject.type === "sub") {
      result[aliasObject.alias] = subResult[aliasObject.index];
    } else {
      result[aliasObject.alias] = mapResult(aliasObject.children, rootRow, subResult);
    }
  }
  return result;
}

// src/utils/stream-consumer.ts
async function readToEnd(readableStream) {
  const actualResult = [];
  for await (const chunk of readableStream) {
    actualResult.push(chunk);
  }
  return actualResult;
}

// src/utils/get-mapped-queries-stream.ts
function getMappedQueriesStream(rootStream, subQueries, aliasMapping, queryDatabase) {
  return new ReadableStream({
    async start(controller) {
      for await (const rootRow of rootStream) {
        const subResult = await Promise.all(
          subQueries.map(async (subQuery) => {
            const generatedSubQuery = subQuery(rootRow);
            const subStream = await queryDatabase(generatedSubQuery.rootQuery);
            const mappedQueriesStream = getMappedQueriesStream(
              subStream,
              generatedSubQuery.subQueries,
              generatedSubQuery.aliasMapping,
              queryDatabase
            );
            return readToEnd(mappedQueriesStream);
          })
        );
        const result = mapResult(aliasMapping, rootRow, subResult);
        controller.enqueue(result);
      }
      controller.close();
    }
  });
}

// src/utils/numeric-operator-conversion.ts
function convertNumericOperators(operation, negate) {
  let result = "";
  switch (operation) {
    case "eq":
      result = `${negate ? "!=" : "="}`;
      break;
    case "gt":
      result = `${negate ? "<=" : ">"}`;
      break;
    case "gte":
      result = `${negate ? "<" : ">="}`;
      break;
    case "lt":
      result = `${negate ? ">=" : "<"}`;
      break;
    case "lte":
      result = `${negate ? ">" : "<="}`;
      break;
    default:
      throw new Error(`Unknown numeric operator: ${operation}`);
  }
  return result;
}
export {
  convertNumericOperators,
  convertQuery,
  createUniqueAlias,
  getMappedQueriesStream,
  mapResult,
  readToEnd
};
