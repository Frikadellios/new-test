import { ReadableStream } from 'node:stream/web';
import { GeoJSONPolygon, GeoJSONMultiPolygon, GeoJSONGeometryCollection, GeoJSONPoint, GeoJSONMultiPoint, GeoJSONLineString, GeoJSONMultiLineString } from 'wellknown';

interface AbstractQueryPrimitive {
    type: 'primitive';
    /** the name of the attribute */
    field: string;
}

/**
 * Generic primitive value read from the store field
 *
 * @example
 * Let's say you want the engine to only return the `id` field of the collection in question:
 * For that you would create a node like the following and add it to the `nodes` of the query.
 * ```
 * const primitiveField: AbstractQueryFieldNodePrimitive = {
 * 	type: 'primitive',
 * 	field: 'attribute_xy'
 * }
 * ```
 */
interface AbstractQueryFieldNodePrimitive extends AbstractQueryPrimitive {
    alias: string;
}

interface ArrayFn {
    type: 'arrayFn';
    fn: 'count';
}

type SupportedExtractFunctions = 'year' | 'month' | 'week' | 'day' | 'weekday' | 'hour' | 'minute' | 'second';
/**
 * To extract a specific part of a date/time value.
 */
interface ExtractFn {
    type: 'extractFn';
    fn: SupportedExtractFunctions;
    isTimestampType?: boolean;
}

interface AbstractQueryFunction {
    type: 'fn';
    fn: ExtractFn | ArrayFn;
    field: string;
    args?: (string | number | boolean)[];
}

/**
 * Used to apply a function to a specific field before returning it.
 *
 * @example
 * There are several functions available.
 * Let's say you want to only return the year of a date field:
 * ```js
 * {
 * 	type: 'fn',
 * 	fn: 'year',
 * 	field: 'date_created'
 * }
 * ```
 */
interface AbstractQueryFieldNodeFn extends AbstractQueryFunction {
    alias: string;
}

type AtLeastOneElement<T> = [T, ...T[]];

/**
 * Used to build a relational query for m2o and o2m relations.
 *
 * A record may be identified across multiple field values (e.g. via a composite primary key in SQL).
 * Hence the field(s) are stored in an array.
 *
 * @example
 * ```
 * const functionNode = {
 * 	local: {
 * 		fields: ['id'],
 *    },
 * 	foreign: {
 * 		store: 'mongodb',
 * 		collection: 'some-collection',
 * 		fields: ['author_id'],
 *    },
 * };
 * ```
 */
interface AbstractQueryFieldNodeNestedRelationalMany {
    type: 'relational-many';
    /**
     * The field names which identify an item in the...
     *
     * m2o: MANY collection. It has the references stored to the ONE item (the foreign key in SQL).
     * o2m: ONE collection. It has the values stored which identifies an item (the primary key in SQL).
     **/
    local: {
        fields: AtLeastOneElement<string>;
    };
    /**
     * m2o: information of the ONE collection
     * o2m: information of the MANY collection
     **/
    foreign: {
        /** In the future this collection can also be stored in a different datastore. */
        store: string;
        collection: string;
        /**
         * The field names which identify an item in the...
         *
         * m2o: ONE collection.
         * o2m: MANY collection.
         **/
        fields: AtLeastOneElement<string>;
    };
}
/**
 * Used to build a relational query for a2o and o2a relations.
 */
interface AbstractQueryFieldNodeNestedRelationalAny {
    type: 'relational-any';
    /** The field name which holds the relational information */
    field: string;
    collections: AbstractQueryFieldNodeNestedRelationalAnyCollection[];
}
interface AbstractQueryFieldNodeNestedRelationalAnyCollection {
    /** The desired fields which should be returned. */
    fields: AbstractQueryFieldNode[];
    /** The relational data which defines how the two collection are related. */
    relational: {
        store: string;
        /** The name of the foreign collection */
        collectionName: string;
        /** The UUID of the foreign collection */
        collectionIdentifier: string;
        /** The column(s) of the foreign collection which store the primary key(s) */
        fields: AtLeastOneElement<string>;
    };
}

/**
 * Node to query data from a m2o relation.
 */
interface AbstractQueryTargetNestedOne {
    type: 'nested-one-target';
    field: AbstractQueryTarget;
    nesting: AbstractQueryFieldNodeNestedRelationalMany;
}

type AbstractQueryTarget = AbstractQueryPrimitive | AbstractQueryFunction | AbstractQueryTargetNestedOne;

/**
 * It's mainly used to compare two fields for relational queries.
 * That's why only the eq comparator is valid.
 */
interface ConditionFieldNode {
    type: 'condition-field';
    target: AbstractQueryTarget;
    operation: 'eq';
    compareTo: AbstractQueryTarget;
}

/**
 * Used to check if geo box objects intersect
 */
interface ConditionGeoIntersectsBBoxNode {
    type: 'condition-geo-intersects-bbox';
    target: AbstractQueryTarget;
    operation: 'intersects_bbox';
    compareTo: GeoJSONPolygon | GeoJSONMultiPolygon | GeoJSONGeometryCollection;
}

/**
 * Checks if a non box geo object intersects with another.
 * @example
 * ```
 * {
 * 	type: 'condition-geo',
 * 	target: {
 * 		type: 'primitive',
 * 		field: 'attribute_xy'
 * 	},
 * 	operation: 'intersects',
 * 	compareTo: {
 * 		"type": "Feature",
 * 		"geometry": {
 *   		"type": "Point",
 *   		"coordinates": [125.6, 10.1]
 * 		},
 *		"properties": {
 *   	"name": "Dinagat Islands"
 * 	}
 * }
 * ```
 */
interface ConditionGeoIntersectsNode {
    type: 'condition-geo-intersects';
    target: AbstractQueryTarget /** the type of the field needs to be a 'geometry' object */;
    operation: 'intersects';
    compareTo: GeoJSONPoint | GeoJSONMultiPoint | GeoJSONLineString | GeoJSONMultiLineString | GeoJSONGeometryCollection;
}

/**
 * Used to compare a number or date time field with a number value.
 * @example
 * ```
 * {
 * 	type: 'condition-number',
 * 	target: {
 * 		type: 'primitive',
 * 		field: 'attribute_xy'
 * 	},
 * 	operation: 'lt',
 * 	compareTo: 5
 * ```
 */
interface ConditionNumberNode {
    type: 'condition-number';
    target: AbstractQueryTarget;
    operation: 'eq' | 'lt' | 'lte' | 'gt' | 'gte';
    compareTo: number;
}

/**
 * Used to compare a number field with a number value.
 * @example
 * ```
 * {
 * 	type: 'condition-set',
 * 	target: {
 * 		type: 'primitive',
 * 		field: 'attribute_xy'
 * 	},
 * 	operation: 'in',
 * 	compareTo: [1, 2, 3]
 * ```
 */
interface ConditionSetNode {
    type: 'condition-set';
    target: AbstractQueryTarget;
    operation: 'in';
    compareTo: (string | number)[];
}

/**
 * Used to compare a string field with a string value.
 *
 * @example
 * ```
 * {
 * 	type: 'condition-string',
 * 	target: {
 * 		type: 'primitive',
 * 		field: 'attribute_xy'
 * 	},
 * 	operation: 'contains',
 * 	compareTo: 'someString'
 * ```
 */
interface ConditionStringNode {
    type: 'condition-string';
    target: AbstractQueryTarget;
    /** @TODO maybe also regex? */
    operation: 'contains' | 'starts_with' | 'ends_with' | 'eq';
    compareTo: string;
}

/**
 * Used to specify a condition on a query.
 * Note: No explicit support to check for 'empty' (it's just an empty string) and null.
 *
 * @example
 * ```
 * {
 * 		type: 'condition',
 * 		condition: {...}
 * },
 * ```
 */
interface AbstractQueryConditionNode {
    type: 'condition';
    condition: ActualConditionNodes;
}
/**
 * Possible nodes which specify the condition.
 *
 * @todo The API should make sure, that the type of the targeting column has the correct type,
 * so that f.e. a condition-string will only be applied to a column of type string.
 */
type ActualConditionNodes = ConditionStringNode | ConditionNumberNode | ConditionGeoIntersectsNode | ConditionGeoIntersectsBBoxNode | ConditionSetNode | ConditionFieldNode;

/**
 * Specifies that the wrapper filter should be negated.
 */
interface AbstractQueryNodeNegate {
    type: 'negate';
    /** the values for the operation. */
    childNode: AbstractQueryFilterNode;
}

/**
 * Used to create logical operations.
 * @example
 * Let's say you want to only return rows where two conditions are true.
 * First condition that some field value needs to be qual to a provided value and another condition that one field is less than another provided value.
 * This would look like this:
 * ```
 * {
 * 	type: 'logical',
 * 	operator: 'and',
 * 	childNodes: [
 * 		{
 * 			type: 'condition',
 * 			condition: {...}
 * 		},
 * 		{
 * 			type: 'condition',
 * 			condition: {...}
 * 		}
 *  ]
 * }
 * ```
 * It is also possible to nest conditions with the logical operator.
 * The following pseudo code mean: A AND (B AND C)
 * ```
 * {
 * 	type: 'logical',
 * 	operator: 'and',
 * 	childNodes: [
 * 		{
 * 			type: 'condition',
 * 			condition: {...}
 * 		},
 * 		{
 * 			type: 'logical',
 * 			operator: 'and',
 * 			childNodes: [
 * 				{
 * 					type: 'condition',
 * 					condition: {...}
 * 				},
 * 				{
 * 					type: 'condition',
 * 					condition: {...}
 * 				},
 * 			],
 * 		}
 *  ]
 * }
 * ```
 */
interface AbstractQueryNodeLogical {
    type: 'logical';
    operator: 'and' | 'or';
    /** the values for the operation. */
    childNodes: AtLeastOneElement<AbstractQueryConditionNode | AbstractQueryNodeLogical | AbstractQueryNodeNegate>;
}

type AbstractQueryFilterNode = AbstractQueryConditionNode | AbstractQueryNodeLogical | AbstractQueryNodeNegate;

/**
 * Specifies the maximum amount of returning results
 */
interface AbstractQueryNodeLimit {
    type: 'limit';
    value: number;
}

/**
 * Specifies the number of items to skip before returning results
 */
interface AbstractQueryNodeOffset {
    type: 'offset';
    value: number;
}

/**
 * Specifies the order of the result, f.e. for a primitive field.
 * @example
 * ```js
 * const sortNode = {
 * 		type: 'sort',
 * 		direction: 'ascending',
 * 		target: {
 * 			type: 'primitive',
 * 			field: 'attribute_xy'
 * 		}
 * }
 * ```
 * Alternatively a function can be applied a the field.
 * The result is then used for sorting.
 * @example
 * ```js
 * const sortNode = {
 * 		type: 'sort',
 * 		direction: 'ascending',
 * 		target: {
 * 			type: 'fn',
 * 			fn: 'year',
 * 			targetNode: {
 * 				type: 'primitive'
 * 				field: 'date_created'
 * 		}
 * }
 */
interface AbstractQueryNodeSort {
    type: 'sort';
    /** the desired order */
    direction: 'ascending' | 'descending';
    /** the node on which the sorting should be applied */
    target: AbstractQueryTarget;
}

/**
 * Optional attributes to customize the query results
 */
interface AbstractQueryModifiers {
    limit?: AbstractQueryNodeLimit;
    offset?: AbstractQueryNodeOffset;
    sort?: AtLeastOneElement<AbstractQueryNodeSort>;
    filter?: AbstractQueryFilterNode;
}

interface AbstractQueryFieldNodeNestedSingleOne {
    type: 'nested-single-one';
    fields: AbstractQueryFieldNode[];
    alias: string;
    nesting: AbstractQueryFieldNodeNestedRelationalMany;
}
interface AbstractQueryFieldNodeNestedUnionOne {
    type: 'nested-union-one';
    alias: string;
    nesting: AbstractQueryFieldNodeNestedRelationalAny;
}
interface AbstractQueryFieldNodeNestedSingleMany {
    type: 'nested-single-many';
    fields: AbstractQueryFieldNode[];
    alias: string;
    /** For many, it's always possible to add modifiers to the foreign collection to adjust the results. */
    modifiers: AbstractQueryModifiers;
    nesting: AbstractQueryFieldNodeNestedRelationalMany;
}
interface AbstractQueryFieldNodeNestedUnionMany {
    type: 'nested-union-many';
    alias: string;
    /** For many, it's always possible to add modifiers to the foreign collection to adjust the results. */
    modifiers: AbstractQueryModifiers;
    nesting: AbstractQueryFieldNodeNestedRelationalAny;
}

type AbstractQueryFieldNode = AbstractQueryFieldNodePrimitive | AbstractQueryFieldNodeFn | AbstractQueryFieldNodeNestedSingleMany | AbstractQueryFieldNodeNestedSingleOne | AbstractQueryFieldNodeNestedUnionMany | AbstractQueryFieldNodeNestedUnionOne;

/**
 * The query can be seen as a tree with various nodes.
 * Each node has a type and different attributes.
 *
 * @module abstract-query
 */

/**
 * The abstract root query
 */
interface AbstractQuery {
    /** Location where the data is stored */
    store: string;
    /** Name of the collection entrypoint within the store */
    collection: string;
    /** All fields to select in the query*/
    fields: AbstractQueryFieldNode[];
    /** Optional attributes to perform a fine granular query */
    modifiers: AbstractQueryModifiers;
}

declare abstract class DataDriver {
    abstract query: (query: AbstractQuery) => Promise<ReadableStream>;
    /**
     * When the driver is first registered. Can be used to warm up caches, prepare connections to
     * databases, login to external services, etc
     */
    register?: () => Promise<void>;
    /**
     * Fires when the driver is no longer needed. Can be used to disconnect databases, logout from
     * services, etc
     */
    destroy?: () => Promise<void>;
}

declare class DataEngine {
    #private;
    constructor();
    /** Registers a new data store for use in queries */
    registerStore(name: string, driver: DataDriver): Promise<void>;
    /** Access the driver of a given store. Errors if it hasn't been registered */
    store(name: string): DataDriver;
    /** Execute a root abstract query */
    query(query: AbstractQuery): Promise<ReadableStream<Record<string, unknown>>>;
    /** Gracefully shutdown connected drivers */
    destroy(): Promise<void>;
}

interface AbstractQueryQuantifierNode {
    type: 'quantifier';
    operator: 'every' | 'some';
    /** The o2m field that the every/some should be applied on */
    target: string;
    /** An alias to reference the o2m item */
    alias: string;
}

export { type AbstractQuery, type AbstractQueryConditionNode, type AbstractQueryFieldNode, type AbstractQueryFieldNodeFn, type AbstractQueryFieldNodeNestedRelationalAny, type AbstractQueryFieldNodeNestedRelationalMany, type AbstractQueryFieldNodeNestedSingleMany, type AbstractQueryFieldNodeNestedSingleOne, type AbstractQueryFieldNodeNestedUnionMany, type AbstractQueryFieldNodeNestedUnionOne, type AbstractQueryFieldNodePrimitive, type AbstractQueryFilterNode, type AbstractQueryFunction, type AbstractQueryModifiers, type AbstractQueryNodeLimit, type AbstractQueryNodeLogical, type AbstractQueryNodeNegate, type AbstractQueryNodeOffset, type AbstractQueryNodeSort, type AbstractQueryPrimitive, type AbstractQueryQuantifierNode, type AbstractQueryTarget, type AbstractQueryTargetNestedOne, type ActualConditionNodes, type ArrayFn, type AtLeastOneElement, type ConditionFieldNode, type ConditionGeoIntersectsBBoxNode, type ConditionGeoIntersectsNode, type ConditionNumberNode, type ConditionSetNode, type ConditionStringNode, DataDriver, DataEngine, type ExtractFn, type SupportedExtractFunctions };
